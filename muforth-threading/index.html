<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html 
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta name="copyright" content="All content on muforth.nimblemachines.com is copyrighted. All rights are reserved." />
<meta name="robots" content="index,follow" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="/-/screen.css" type="text/css" />
<link rel="canonical" href="http://muforth.nimblemachines.com/muforth-threading/" />
<title>MuFORTH threading &ndash; muFORTH</title>
</head>
<body>

<div id="header">
<h1>MuFORTH threading</h1>
<hr />
</div>

<div id="content">
<p>Here is some code. I&rsquo;ll come back and explain it.</p>
<pre>
 /*
  * This is where all the magic happens. Any time we have the address of a
  * word to execute (an execution token, or XTK) - either because we looked
  * it up in the dictionary, or because we fetched it out of a variable - we
  * call execute_xtk. It is most commonly invoked by EXECUTE, which POPs an
  * xtk off the D stack, and calls execute_xtk.
  *
  * We need magic here because of the hybrid nature of the system. It is
  * *not* a truly indirect-threaded Forth, where you set up IP and go, and
  * never look back. We're executing C code, then Forth, then C... The Forth
  * inner interpreter never runs "free"; in fact, we run it in this routine!
  *
  * How do we know if the XTK refers to a Forth word or to a C routine? We
  * don't...until we run it. If it's Forth, the first thing it will do is
  * NEST - push the caller's IP - and then it will set IP to point to its
  * own code. In fact, that's *all* Forth words do when you execute them!
  *
  * So we save RP, then call the word. Then we loop *while* the current RP
  * is *strictly* less than the saved. If we didn't call a Forth word, this
  * will not be true, and we'll exit. But the word we called - the C routine
  * - will have run its course and done all its work.
  *
  * If it *was* a Forth word, it NESTED, and RP &lt; rp_saved. So now we run
  * NEXT - a "constrained" threaded interpreter - until RP >= rp_saved, which
  * will happen precisely when the called (Forth) word executes UNNEST
  * (EXIT).
  *
  * That's all there is to it!
  *
  * Thanks to Michael Pruemm for the idea of comparing RP to rp_saved as a
  * way to see when we're "done".
  */
 void execute_xtk(xtk x)
 {
     xtk **rp_saved;
</pre>
<pre>
     rp_saved = RP;
</pre>
<pre>
     CALL(x);
     while (RP &lt; rp_saved)
         NEXT;
 }
</pre>
<pre>
 /* The most important "word" of all: */
 void mu_do_colon()
 {
     NEST;                   /* entering a new word; push IP */
     IP = (xtk *)&amp;W[1];      /* new IP is address of parameter field */
 }
</pre>
<pre>
 /* The basis of create/does>. */
 void mu_do_does()
 {
     NEST;                   /* entering a new word; push IP */
     IP = (xtk *)W[1];       /* new IP is stored in the parameter field */
     PUSH(W[2]);             /* push the constant stored in 2nd word */
 }
</pre>

</div>

<div id="footer">
<hr />
<a href="mailto:%77%65%62%68%61%6d%73%74%65%72%40%6e%69%6d%62%6c%65%6d%61%63%68%69%6e%65%73%2e%63%6f%6d?subject=MuFORTH%20threading">Send feedback</a> on this page (last edited 2006 April 03 12:09)<br />
Browse <a href="/all-pages/">all pages</a>, or return <a href="/">home</a>
</div>

</body>
</html>
